name: IoT Firmware Build & Auto-Release

on:
  push:
    branches: [ main ]
    tags:
      - 'v*.*.*'
  pull_request:
    branches: [ main ]

permissions:
  contents: write

jobs:
  build:
    if: "!contains(github.event.head_commit.message, 'chore(release):')"
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Extract Version Info
        id: versioning
        run: |
          git fetch --tags
          # Получаем последний тег или v0.0.0
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          CLEAN_TAG=${LATEST_TAG#v}
          
          # Разбиваем версию на компоненты
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CLEAN_TAG"
          
          # Логика: если это пуш в main, инкрементируем PATCH для новой сборки
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            PATCH=$((PATCH + 1))
            NEW_TAG="v$MAJOR.$MINOR.$PATCH"
          else
            # Если мы на теге или PR, используем текущий контекст
            NEW_TAG=${{ github.ref_name }}
          fi
          
          echo "MAJOR=$MAJOR" >> $GITHUB_ENV
          echo "MINOR=$MINOR" >> $GITHUB_ENV
          echo "PATCH=$PATCH" >> $GITHUB_ENV
          echo "TAG_NAME=$NEW_TAG" >> $GITHUB_ENV
          echo "GIT_SHA=$(git rev-parse --short HEAD)" >> $GITHUB_ENV

      - name: Generate version.h
        run: |
          mkdir -p include
          # Генерируем файл. Он будет перезаписан, даже если существовал.
          cat <<EOF > include/version.h
          // Generated by GitHub Actions. DO NOT EDIT.
          #ifndef INCLUDE_VERSION_H_
          #define INCLUDE_VERSION_H_
          #include <string_view>
          namespace firmware::version {
          inline constexpr std::string_view kFirmwareVersion = "${{ env.TAG_NAME }}";
          inline constexpr std::string_view kGitSha = "${{ env.GIT_SHA }}";
          inline constexpr std::string_view kBuildTimestamp = "$(date -u +'%Y-%m-%dT%H:%M:%SZ')";
          inline constexpr int kMajor = ${{ env.MAJOR }};
          inline constexpr int kMinor = ${{ env.MINOR }};
          inline constexpr int kPatch = ${{ env.PATCH }};
          }
          #endif
          EOF

      - name: Install PlatformIO & Build Tools
        run: |
          python -m pip install --upgrade pip
          pip install platformio cython setuptools wheel pyyaml littlefs-python

      - name: Custom pyfatfs build
        run: |
          cd /tmp && git clone https://github.com/Jason2866/pyfatfs && cd pyfatfs
          python -m cython fatfs/wrapper.pyx
          pip install .
          cd ${{ github.workspace }}

      - name: Build Firmware
        run: pio run

      - name: Rename Artifact
        run: |
          # Копируем бинарник с красивым именем для релиза
          mkdir -p release_dist
          find .pio/build -name "firmware.bin" -exec cp {} release_dist/zigbee_water_meter_${{ env.TAG_NAME }}.bin \;

      - name: Create GitHub Release and Attach Asset
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.TAG_NAME }}
          name: Release ${{ env.TAG_NAME }}
          files: release_dist/*.bin
          body: |
            ## Автоматическая сборка прошивки
            - **Версия:** ${{ env.TAG_NAME }}
            - **Commit:** ${{ env.GIT_SHA }}
            - **Дата:** $(date -u +'%Y-%m-%d %H:%M:%SZ')
          generate_release_notes: true
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
